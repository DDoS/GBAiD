module gbaid.gba.instable;

import std.range : iota;
import std.traits : hasUDA;
import std.meta : aliasSeqOf;
import std.algorithm.searching : count;
import std.string : format;

import gbaid.util;

public import gbaid.gba.register;
public import gbaid.gba.memory;

public alias Executor = void function(Registers*, MemoryBus*, int);

public Executor[] createTable(alias nullInstruction)(int bitCount) {
    auto table = new Executor[1 << bitCount];
    foreach (i, t; table) {
        table[i] = &nullInstruction;
    }
    return table;
}

public void addSubTable(string bits, alias instructionFamily, alias nullInstruction)(Executor[] table) {
    // Generate the subtable
    auto subTable = createTable!(instructionFamily, bits.count('t'), nullInstruction)();
    // Check that there are as many bits as in the table length
    int bitCount = cast(int) bits.length;
    if (1 << bitCount != table.length) {
        throw new Exception("Wrong number of bits");
    }
    // Count don't cares and table bits (and validate bit types)
    int dontCareCount = 0;
    int tableBitCount = 0;
    foreach (b; bits) {
        switch (b) {
            case '0':
            case '1':
                break;
            case 'd':
                dontCareCount++;
                break;
            case 't':
                tableBitCount++;
                break;
            default:
                throw new Exception("Unknown bit type: '" ~ b ~ "'");
        }
    }
    if (1 << tableBitCount != subTable.length) {
        throw new Exception("Wrong number of sub-table bits");
    }
    // Enumerate combinations generated by the bit string
    // 0 and 1 literals, d for don't care, t for table
    // Start with all the 1 literals, which won't change
    int fixed = 0;
    foreach (int i, b; bits) {
        if (b == '1') {
            fixed.setBit(bitCount - 1 - i, 1);
        }
    }
    // Now for every combination of don't cares create an
    // intermediary value, which is only missing table bits
    foreach (dontCareValue; 0 .. 1 << dontCareCount) {
        int intermediary = fixed;
        int dc = dontCareCount - 1;
        foreach (int i, b; bits) {
            if (b == 'd') {
                intermediary.setBit(bitCount - 1 - i, dontCareValue.getBit(dc));
                dc--;
            }
        }
        // Now for every combination of table bits create the
        // final value and assign the pointer in the table
        foreach (tableBitValue; 0 .. 1 << tableBitCount) {
            // Ignore null instructions
            if (subTable[tableBitValue] is &nullInstruction) {
                continue;
            }
            int index = intermediary;
            int tc = tableBitCount - 1;
            foreach (int i, b; bits) {
                if (b == 't') {
                    index.setBit(bitCount - 1 - i, tableBitValue.getBit(tc));
                    tc--;
                }
            }
            // Check if there's a conflict first
            if (table[index] !is &nullInstruction) {
                throw new Exception(format("The entry at index %d in sub-table with bits \"%s\" conflicts with "
                        ~ "a previously added one", tableBitValue, bits));
            }
            table[index] = subTable[tableBitValue];
        }
    }
}

private Executor[] createTable(alias instructionFamily, int bitCount, alias unsupported)() {
    static if (bitCount == 0) {
        Executor[] table = [&instructionFamily!()];
    } else {
        Executor[] table;
        foreach (i; aliasSeqOf!(iota(0, 1 << bitCount))) {
            static if (hasUDA!(instructionFamily!i, "unsupported")) {
                table ~= [&unsupported];
            } else {
                table ~= [&instructionFamily!i];
            }
        }
    }
    return table;
}
